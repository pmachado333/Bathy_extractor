<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Earth Vision Grid - FDPlan Input Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.10.0/dist/proj4.js"></script>
  <style>
    :root{
      --slb:#003366; --slb-600:#1c5991; --ink:#0b1320; --muted:#64748b;
      --bg:#f7f9fc; --card:#ffffff; --bd:#e6eef7; --ok:#0f9d58; --err:#c62828;
      --r:14px;
    }
    *{box-sizing:border-box} html,body{height:100%} body{
      margin:0; font-family:system-ui, Segoe UI, Roboto, Inter, Arial; color:var(--ink); background:var(--bg);
    }
    header{background:var(--slb); color:#fff; padding:14px 16px}
    header .wrap{max-width:960px; margin:0 auto; display:flex; justify-content:space-between; align-items:center}
    main{max-width:960px; margin:18px auto; padding:0 12px}
    .card{background:var(--card); border:1px solid var(--bd); border-radius:var(--r); box-shadow:0 6px 24px rgba(0,0,0,.06);}
    .content{padding:16px}
    .grid{display:grid; gap:16px}
    @media (min-width:900px){ .grid-2{grid-template-columns:1fr 1fr} }
    h1{margin:0; font-size:18px; font-weight:800; letter-spacing:.2px}
    .sub{opacity:.9; font-size:12px}
    h2{margin:0 0 6px; font-size:15px}
    .group{border:1px solid var(--bd); border-radius:12px; padding:12px}
    .row2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    label{display:block; font-weight:600; font-size:13px; margin-bottom:6px; color:#0e2a4f}
    input[type="number"], input[type="text"]{
      width:100%; padding:10px 12px; border:1px solid #d7e3f4; border-radius:10px; font-size:14px; background:#fff;
      outline:none; transition:border .15s, box-shadow .15s;
    }
    input:focus{border-color:var(--slb-600); box-shadow:0 0 0 3px rgba(28,89,145,.15)}
    .desc{margin:6px 0 0; font-size:12px; color:var(--muted)}
    .switch{display:flex; align-items:center; gap:10px; margin-top:6px}
    .actions{display:flex; gap:10px; align-items:center; margin-top:8px}
    button{
      border:none; background:var(--slb); color:#fff; padding:12px 16px; border-radius:12px; font-weight:800; cursor:pointer;
      box-shadow:0 8px 18px rgba(0,51,102,.25); transition:filter .15s, transform .06s;
    }
    button:hover{filter:brightness(1.05)} button:active{transform:translateY(1px)}
    .status{min-height:20px; font-size:13px; color:var(--muted)}
    .status.ok{color:var(--ok)} .status.err{color:var(--err)}
    details{border-top:1px solid var(--bd); padding:10px 16px}
    summary{cursor:pointer; font-weight:700; color:#0e3770}
    pre{background:#0c1b33; color:#e7eefc; border:1px solid #243a67; border-radius:10px; padding:10px; white-space:pre; overflow:auto; font-family:ui-monospace, Menlo, Consolas, monospace; min-height:120px; margin-top:8px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>
        <h1>GEBCO — Run & Download</h1>
        <div class="sub">by Patrick Machado</div>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="content">
        <div class="grid grid-2">
          <!-- Coordinates -->
          <div class="group">
            <h2>Coordinates</h2>
            <div class="row2">
              <div>
                <label for="lonStart">Longitude start</label>
                <input id="lonStart" type="number" step="0.0001" />
                <div class="desc">Western boundary in degrees (e.g., −44.87).</div>
              </div>
              <div>
                <label for="lonEnd">Longitude end</label>
                <input id="lonEnd" type="number" step="0.0001" />
                <div class="desc">Eastern boundary in degrees (e.g., −44.48). Must be ≥ start.</div>
              </div>
            </div>
            <div class="row2" style="margin-top:8px">
              <div>
                <label for="latStart">Latitude start</label>
                <input id="latStart" type="number" step="0.0001" />
                <div class="desc">Southern boundary in degrees (e.g., −25.85).</div>
              </div>
              <div>
                <label for="latEnd">Latitude end</label>
                <input id="latEnd" type="number" step="0.0001" />
                <div class="desc">Northern boundary in degrees (e.g., −25.45). Must be ≥ start.</div>
              </div>
            </div>
          </div>

          <!-- Projection & Grid -->
          <div class="group">
            <h2>Projection & Grid</h2>
            <div class="row2">
              <div>
                <label for="zone">UTM Zone</label>
                <input id="zone" type="number" min="1" max="60" step="1" />
                <div class="desc">UTM longitudinal zone (1–60). Example: 23 for SE Brazil.</div>
              </div>
              <div class="switch">
                <input id="south" type="checkbox" />
                <label for="south">South Hemisphere</label>
              </div>
            </div>
            <div class="row2" style="margin-top:8px">
              <div>
                <label for="sample">sample (integer string)</label>
                <input id="sample" type="text" inputmode="numeric" />
                <div class="desc">Resampling parameter for API; leave as “1” unless advised.</div>
              </div>
              <div>
                <label for="dxdy">Grid spacing (m) — dx=dy</label>
                <input id="dxdy" type="number" min="1" step="1" />
                <div class="desc">Cell spacing (meters) in UTM. Larger = coarser grid.</div>
              </div>
            </div>
            <div style="margin-top:8px; max-width:260px">
              <label for="edgeSteps">Edge offset (steps)</label>
              <input id="edgeSteps" type="number" min="0" step="1" />
              <div class="desc">Keep grid a few steps inside the bounds to avoid touching edges.</div>
            </div>
          </div>
        </div>

        <div class="actions">
          <button id="btnRun" type="button">Run — Call API & Download</button>
          <span id="status" class="status">Idle</span>
        </div>
      </div>

      <!-- Collapsed debug panes -->
      <details>
        <summary>API Response (raw JSON)</summary>
        <pre id="apiOut"></pre>
      </details>
      <details>
        <summary>Processed Preview (first 30 rows)</summary>
        <pre id="tabOut"></pre>
      </details>
    </section>
  </main>

<script>
  // Defaults
  const defaults = {
    coordinates:{ longitude:{ start:-44.87, end:-44.48 }, latitude:{ start:-25.85, end:-25.45 } },
    zone:23, South:true, sample:"1", dxdy:200, edgeSteps:3
  };

  // Elements
  const els = {
    lonStart: document.getElementById('lonStart'),
    lonEnd:   document.getElementById('lonEnd'),
    latStart: document.getElementById('latStart'),
    latEnd:   document.getElementById('latEnd'),
    zone:     document.getElementById('zone'),
    south:    document.getElementById('south'),
    sample:   document.getElementById('sample'),
    dxdy:     document.getElementById('dxdy'),
    edge:     document.getElementById('edgeSteps'),
    run:      document.getElementById('btnRun'),
    status:   document.getElementById('status'),
    apiOut:   document.getElementById('apiOut'),
    tabOut:   document.getElementById('tabOut'),
  };

  function setDefaults(){
    els.lonStart.value = defaults.coordinates.longitude.start;
    els.lonEnd.value   = defaults.coordinates.longitude.end;
    els.latStart.value = defaults.coordinates.latitude.start;
    els.latEnd.value   = defaults.coordinates.latitude.end;
    els.zone.value     = defaults.zone;
    els.south.checked  = defaults.South;
    els.sample.value   = defaults.sample;
    els.dxdy.value     = defaults.dxdy;
    els.edge.value     = defaults.edgeSteps;
  }
  function setStatus(msg, kind){ els.status.textContent = msg; els.status.className = 'status ' + (kind || ''); }

  // Build polygon URL
  function buildRing({lonStart,lonEnd,latStart,latEnd}){
    return [
      [lonStart, latStart],
      [lonStart, latEnd],
      [lonEnd,   latEnd],
      [lonEnd,   latStart],
      [lonStart, latStart]
    ];
  }
  function buildUrl(sample, ring){
    const poly = { type:'Polygon', coordinates:[ ring ] };
    const jsonsrc = encodeURIComponent(JSON.stringify(poly));
    return `https://api.odb.ntu.edu.tw/gebco?mode=Polygon&sample=${encodeURIComponent(String(sample))}&jsonsrc=${jsonsrc}`;
  }

  // Networking
  async function callApi(url){
    const res = await fetch(url, { headers: { accept:'application/json' } });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const txt = await res.text();
    try { return JSON.parse(txt); } catch { return txt; }
  }

  // Math / processing
  function makeAxisInner(min, max, step, edgeSteps){
    const eps=1e-9, pad=Math.max(0, edgeSteps|0)*step;
    const startBound=min+pad, endBound=max-pad;
    const vals=[];
    if (endBound - startBound <= step + eps) return { vals:[], startBound, endBound };
    for(let v=startBound; v<=endBound - step - eps; v+=step) vals.push(v);
    return { vals, startBound, endBound };
  }
  function knnIndices(points, qx, qy, k=12){ const d=points.map((p,i)=>[i,(p[0]-qx)**2+(p[1]-qy)**2]); d.sort((a,b)=>a[1]-b[1]); return d.slice(0,Math.min(k,d.length)).map(x=>x[0]); }
  function idwInterpolate(points, values, qx, qy, k=12, power=2, eps=1e-12){
    const idxs = knnIndices(points, qx, qy, k); let num=0, den=0;
    for(const i of idxs){ const dx=points[i][0]-qx, dy=points[i][1]-qy; const d2=dx*dx+dy*dy; if (d2<eps) return values[i]; const w=1/Math.pow(d2,power/2); num+=w*values[i]; den+=w; }
    return den>0 ? num/den : NaN;
  }
  function nearest(points, values, qx, qy){ let bi=-1, bd=Infinity; for(let i=0;i<points.length;i++){ const dx=points[i][0]-qx, dy=points[i][1]-qy, d=dx*dx+dy*dy; if(d<bd){bd=d;bi=i;} } return values[bi]; }
  function gaussianKernel1D(sigma){ const r=Math.max(1,Math.floor(sigma*3)); const k=[]; let s=0, s2=2*sigma*sigma; for(let i=-r;i<=r;i++){ const v=Math.exp(-(i*i)/s2); k.push(v); s+=v;} return k.map(v=>v/s); }
  function convolveSeparable2D(Z, W, H, kernel){
    const r=(kernel.length-1)/2, tmp=new Float64Array(Z.length), out=new Float64Array(Z.length);
    for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ let a=0; for(let i=-r;i<=r;i++){ const xx=Math.min(W-1,Math.max(0,x+i)); a+=kernel[i+r]*Z[y*W+xx]; } tmp[y*W+x]=a; } }
    for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ let a=0; for(let j=-r;j<=r;j++){ const yy=Math.min(H-1,Math.max(0,y+j)); a+=kernel[j+r]*tmp[yy*W+x]; } out[y*W+x]=a; } }
    return out;
  }
  function normalizeApiData(apiData){
    if (apiData && Array.isArray(apiData.longitude) && Array.isArray(apiData.latitude) && Array.isArray(apiData.z)) {
      const L = Math.min(apiData.longitude.length, apiData.latitude.length, apiData.z.length);
      const rows = new Array(L);
      for (let i=0;i<L;i++){
        rows[i] = {
          longitude: +apiData.longitude[i],
          latitude:  +apiData.latitude[i],
          Z:         +apiData.z[i],
          distance:  apiData.distance ? (+apiData.distance[i] || 0) : 0
        };
      }
      return rows;
    }
    if (Array.isArray(apiData) && apiData.length){
      if (Array.isArray(apiData[0])) return apiData.map(r=>({longitude:+r[0],latitude:+r[1],Z:+r[2],distance:+(r[3]||0)}));
      if (typeof apiData[0]==='object') return apiData.map(o=>({longitude:+(o.longitude??o.lon??o[0]),latitude:+(o.latitude??o.lat??o[1]),Z:+(o.Z??o.z??o[2]),distance:+(o.distance??o[3]??0)}));
    }
    throw new Error('Unexpected API format (need longitude[], latitude[], z[]).');
  }

  function processData({ apiData, zone, South, dxdy, edgeSteps }){
    const rows = normalizeApiData(apiData);

    const utm = `+proj=utm +zone=${zone} ${South?'+south':''} +datum=WGS84 +units=m +no_defs`;
    const proj = proj4('WGS84', utm);
    rows.forEach(r => { const xy = proj.forward([r.longitude, r.latitude]); r.X=xy[0]; r.Y=xy[1]; });

    const dx=dxdy, dy=dxdy;
    const x_min = Math.min(...rows.map(r=>r.X)), x_max = Math.max(...rows.map(r=>r.X));
    const y_min = Math.min(...rows.map(r=>r.Y)), y_max = Math.max(...rows.map(r=>r.Y));
    const axX = makeAxisInner(x_min, x_max, dx, edgeSteps);
    const axY = makeAxisInner(y_min, y_max, dy, edgeSteps);
    const x_vals = axX.vals, y_vals = axY.vals;

    if (x_vals.length===0 || y_vals.length===0) {
      throw new Error('No interior grid after edge offset. Reduce offset or spacing.');
    }

    const pts = rows.map(r=>[r.X,r.Y]); const vals = rows.map(r=>r.Z);
    const W=x_vals.length, H=y_vals.length;
    let Zg = new Float64Array(W*H);
    for(let j=0;j<H;j++){ const y=y_vals[j];
      for(let i=0;i<W;i++){ const x=x_vals[i];
        let z = idwInterpolate(pts, vals, x, y, 12, 2);
        if (Number.isNaN(z)) z = nearest(pts, vals, x, y);
        Zg[j*W+i]=z;
      }
    }
    const kernel = gaussianKernel1D(5);
    Zg = convolveSeparable2D(Zg, W, H, kernel);

    const grid = [];
    for(let r=0;r<H;r++){ const y=y_vals[r];
      for(let c=0;c<W;c++){ const x=x_vals[c]; const z=Zg[r*W+c];
        grid.push([+x.toFixed(4), +y.toFixed(4), z, c+1, r+1]);
      }
    }
    grid.sort((a,b)=> (a[4]-b[4]) || (a[3]-b[3]));

    const x0 = +axX.startBound.toFixed(4), x1 = +axX.endBound.toFixed(4);
    const y0 = +axY.startBound.toFixed(4), y1 = +axY.endBound.toFixed(4);
    const header =
`# Type: scattered data
# Version: 6
# Description: No description
# Format: free
# Field: 1 x
# Field: 2 y
# Field: 3 z meters
# Field: 4 column
# Field: 5 row
# Projection: Local Rectangular
# Units: meters
# End:
# Information from grid:
# Grid_size: ${W} x ${H}
# Grid_space: ${x0},${x1},${y0},${y1}
# Scattered data: Not_available
# Z_field: z
# Vertical_faults: Not_available
# History: No history
# Z_units: meters
`;
    const csvBody = grid.map(r => `${r[0]} ${r[1]} ${r[2]} ${r[3]} ${r[4]}`).join('\n');
    const finalText = header + csvBody;
    const preview = grid.slice(0,30).map(r=>`${r[0]} ${r[1]} ${r[2].toFixed(3)} ${r[3]} ${r[4]}`).join('\n');

    return { finalText, preview, dims:{x:W,y:H}, bounds:{xmin:x0,xmax:x1,ymin:y0,ymax:y1} };
  }

  // Orchestration
  async function runOnce(){
    try{
      setStatus('Calling API…');
      const lonStart = Number(els.lonStart.value);
      const lonEnd   = Number(els.lonEnd.value);
      const latStart = Number(els.latStart.value);
      const latEnd   = Number(els.latEnd.value);
      const zone     = Number(els.zone.value);
      const South    = !!els.south.checked;

      if ([lonStart,lonEnd,latStart,latEnd,zone].some(n=>Number.isNaN(n))) throw new Error('All fields must be numbers.');
      if (lonStart>lonEnd) throw new Error('Longitude start ≤ end.');
      if (latStart>latEnd) throw new Error('Latitude start ≤ end.');
      if (zone<1 || zone>60) throw new Error('UTM zone must be 1..60.');

      const ring = buildRing({lonStart,lonEnd,latStart,latEnd});
      const url  = buildUrl(els.sample.value || '1', ring);
      const apiData = await callApi(url);
      els.apiOut.textContent = typeof apiData === 'string' ? apiData : JSON.stringify(apiData, null, 2);

      setStatus('Processing…');
      const res = processData({
        apiData, zone, South,
        dxdy: Math.max(1, Number(els.dxdy.value) || 200),
        edgeSteps: Math.max(0, Math.floor(Number(els.edge.value) || 3))
      });

      els.tabOut.textContent =
        `# Grid ${res.dims.x} x ${res.dims.y}\n` +
        `# X:[${res.bounds.xmin.toFixed(4)}, ${res.bounds.xmax.toFixed(4)}]  ` +
        `Y:[${res.bounds.ymin.toFixed(4)}, ${res.bounds.ymax.toFixed(4)}]\n\n` +
        res.preview;

      const blob = new Blob([res.finalText], {type:'text/plain;charset=utf-8'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='updated_bathymetry_data_LATLONG';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);

      setStatus('Done. File downloaded.', 'ok');
    }catch(e){
      setStatus(e?.message || String(e), 'err');
    }
  }

  els.run.addEventListener('click', runOnce);
  setDefaults();
</script>
</body>
</html>
